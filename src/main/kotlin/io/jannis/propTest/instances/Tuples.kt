/*
  AUTOGENERATED FILE. DON'T EDIT DIRECTLY
  This file was generated by tuple.generator.kts
*/
package io.jannis.propTest.instances

import io.jannis.propTest.*
import arrow.core.*
import io.jannis.propTest.instances.tuple2.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple3.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple4.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple5.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple6.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple7.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple8.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple9.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple10.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple11.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple12.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple13.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple14.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple15.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple16.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple17.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple18.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple19.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple20.arbitrary.arbitrary
import io.jannis.propTest.instances.tuple21.arbitrary.arbitrary
import arrow.extension

@extension
interface Tuple2Arbitrary<A, B> : Arbitrary<Tuple2<A, B>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    override fun arbitrary(): Gen<Tuple2<A, B>> = Gen.monad().fx {
        Tuple2(AA().arbitrary().bind(), AB().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple2<A, B>): Sequence<Tuple2<A, B>> =
        AA().shrink(fail.a).map { Tuple2(it, fail.b) } +
            AB().shrink(fail.b).map { Tuple2(fail.a, it) }
}

inline fun <reified A, reified B, F1> fromTup(
    noinline g: (F1) -> Tuple2<A, B>,
    noinline f: (Tuple2<A, B>) -> F1,
    arb: Arbitrary<Tuple2<A, B>> = Tuple2.arbitrary(defArbitrary(), defArbitrary())
): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple3Arbitrary<A, B, C> : Arbitrary<Tuple3<A, B, C>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    override fun arbitrary(): Gen<Tuple3<A, B, C>> = Gen.monad().fx {
        Tuple3(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple3<A, B, C>): Sequence<Tuple3<A, B, C>> =
        AA().shrink(fail.a).map { Tuple3(it, fail.b, fail.c) } +
            AB().shrink(fail.b).map { Tuple3(fail.a, it, fail.c) } +
            AC().shrink(fail.c).map { Tuple3(fail.a, fail.b, it) }
}

inline fun <reified A, reified B, reified C, F1> fromTup(
    noinline g: (F1) -> Tuple3<A, B, C>,
    noinline f: (Tuple3<A, B, C>) -> F1,
    arb: Arbitrary<Tuple3<A, B, C>> = Tuple3.arbitrary(defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple4Arbitrary<A, B, C, D> : Arbitrary<Tuple4<A, B, C, D>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    override fun arbitrary(): Gen<Tuple4<A, B, C, D>> = Gen.monad().fx {
        Tuple4(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple4<A, B, C, D>): Sequence<Tuple4<A, B, C, D>> =
        AA().shrink(fail.a).map { Tuple4(it, fail.b, fail.c, fail.d) } +
            AB().shrink(fail.b).map { Tuple4(fail.a, it, fail.c, fail.d) } +
            AC().shrink(fail.c).map { Tuple4(fail.a, fail.b, it, fail.d) } +
            AD().shrink(fail.d).map { Tuple4(fail.a, fail.b, fail.c, it) }
}

inline fun <reified A, reified B, reified C, reified D, F1> fromTup(
    noinline g: (F1) -> Tuple4<A, B, C, D>,
    noinline f: (Tuple4<A, B, C, D>) -> F1,
    arb: Arbitrary<Tuple4<A, B, C, D>> = Tuple4.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple5Arbitrary<A, B, C, D, E> : Arbitrary<Tuple5<A, B, C, D, E>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    override fun arbitrary(): Gen<Tuple5<A, B, C, D, E>> = Gen.monad().fx {
        Tuple5(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple5<A, B, C, D, E>): Sequence<Tuple5<A, B, C, D, E>> =
        AA().shrink(fail.a).map { Tuple5(it, fail.b, fail.c, fail.d, fail.e) } +
            AB().shrink(fail.b).map { Tuple5(fail.a, it, fail.c, fail.d, fail.e) } +
            AC().shrink(fail.c).map { Tuple5(fail.a, fail.b, it, fail.d, fail.e) } +
            AD().shrink(fail.d).map { Tuple5(fail.a, fail.b, fail.c, it, fail.e) } +
            AE().shrink(fail.e).map { Tuple5(fail.a, fail.b, fail.c, fail.d, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, F1> fromTup(
    noinline g: (F1) -> Tuple5<A, B, C, D, E>,
    noinline f: (Tuple5<A, B, C, D, E>) -> F1,
    arb: Arbitrary<Tuple5<A, B, C, D, E>> = Tuple5.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple6Arbitrary<A, B, C, D, E, F> : Arbitrary<Tuple6<A, B, C, D, E, F>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    override fun arbitrary(): Gen<Tuple6<A, B, C, D, E, F>> = Gen.monad().fx {
        Tuple6(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple6<A, B, C, D, E, F>): Sequence<Tuple6<A, B, C, D, E, F>> =
        AA().shrink(fail.a).map { Tuple6(it, fail.b, fail.c, fail.d, fail.e, fail.f) } +
            AB().shrink(fail.b).map { Tuple6(fail.a, it, fail.c, fail.d, fail.e, fail.f) } +
            AC().shrink(fail.c).map { Tuple6(fail.a, fail.b, it, fail.d, fail.e, fail.f) } +
            AD().shrink(fail.d).map { Tuple6(fail.a, fail.b, fail.c, it, fail.e, fail.f) } +
            AE().shrink(fail.e).map { Tuple6(fail.a, fail.b, fail.c, fail.d, it, fail.f) } +
            AF().shrink(fail.f).map { Tuple6(fail.a, fail.b, fail.c, fail.d, fail.e, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, F1> fromTup(
    noinline g: (F1) -> Tuple6<A, B, C, D, E, F>,
    noinline f: (Tuple6<A, B, C, D, E, F>) -> F1,
    arb: Arbitrary<Tuple6<A, B, C, D, E, F>> = Tuple6.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple7Arbitrary<A, B, C, D, E, F, G> : Arbitrary<Tuple7<A, B, C, D, E, F, G>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    override fun arbitrary(): Gen<Tuple7<A, B, C, D, E, F, G>> = Gen.monad().fx {
        Tuple7(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple7<A, B, C, D, E, F, G>): Sequence<Tuple7<A, B, C, D, E, F, G>> =
        AA().shrink(fail.a).map { Tuple7(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g) } +
            AB().shrink(fail.b).map { Tuple7(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g) } +
            AC().shrink(fail.c).map { Tuple7(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g) } +
            AD().shrink(fail.d).map { Tuple7(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g) } +
            AE().shrink(fail.e).map { Tuple7(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g) } +
            AF().shrink(fail.f).map { Tuple7(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g) } +
            AG().shrink(fail.g).map { Tuple7(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, F1> fromTup(
    noinline g: (F1) -> Tuple7<A, B, C, D, E, F, G>,
    noinline f: (Tuple7<A, B, C, D, E, F, G>) -> F1,
    arb: Arbitrary<Tuple7<A, B, C, D, E, F, G>> = Tuple7.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple8Arbitrary<A, B, C, D, E, F, G, H> : Arbitrary<Tuple8<A, B, C, D, E, F, G, H>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    override fun arbitrary(): Gen<Tuple8<A, B, C, D, E, F, G, H>> = Gen.monad().fx {
        Tuple8(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple8<A, B, C, D, E, F, G, H>): Sequence<Tuple8<A, B, C, D, E, F, G, H>> =
        AA().shrink(fail.a).map { Tuple8(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h) } +
            AB().shrink(fail.b).map { Tuple8(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h) } +
            AC().shrink(fail.c).map { Tuple8(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h) } +
            AD().shrink(fail.d).map { Tuple8(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h) } +
            AE().shrink(fail.e).map { Tuple8(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h) } +
            AF().shrink(fail.f).map { Tuple8(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h) } +
            AG().shrink(fail.g).map { Tuple8(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h) } +
            AH().shrink(fail.h).map { Tuple8(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, F1> fromTup(
    noinline g: (F1) -> Tuple8<A, B, C, D, E, F, G, H>,
    noinline f: (Tuple8<A, B, C, D, E, F, G, H>) -> F1,
    arb: Arbitrary<Tuple8<A, B, C, D, E, F, G, H>> = Tuple8.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple9Arbitrary<A, B, C, D, E, F, G, H, I> : Arbitrary<Tuple9<A, B, C, D, E, F, G, H, I>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    override fun arbitrary(): Gen<Tuple9<A, B, C, D, E, F, G, H, I>> = Gen.monad().fx {
        Tuple9(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple9<A, B, C, D, E, F, G, H, I>): Sequence<Tuple9<A, B, C, D, E, F, G, H, I>> =
        AA().shrink(fail.a).map { Tuple9(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i) } +
            AB().shrink(fail.b).map { Tuple9(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i) } +
            AC().shrink(fail.c).map { Tuple9(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i) } +
            AD().shrink(fail.d).map { Tuple9(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i) } +
            AE().shrink(fail.e).map { Tuple9(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i) } +
            AF().shrink(fail.f).map { Tuple9(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i) } +
            AG().shrink(fail.g).map { Tuple9(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i) } +
            AH().shrink(fail.h).map { Tuple9(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i) } +
            AI().shrink(fail.i).map { Tuple9(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, F1> fromTup(
    noinline g: (F1) -> Tuple9<A, B, C, D, E, F, G, H, I>,
    noinline f: (Tuple9<A, B, C, D, E, F, G, H, I>) -> F1,
    arb: Arbitrary<Tuple9<A, B, C, D, E, F, G, H, I>> = Tuple9.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple10Arbitrary<A, B, C, D, E, F, G, H, I, J> : Arbitrary<Tuple10<A, B, C, D, E, F, G, H, I, J>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    override fun arbitrary(): Gen<Tuple10<A, B, C, D, E, F, G, H, I, J>> = Gen.monad().fx {
        Tuple10(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple10<A, B, C, D, E, F, G, H, I, J>): Sequence<Tuple10<A, B, C, D, E, F, G, H, I, J>> =
        AA().shrink(fail.a).map { Tuple10(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j) } +
            AB().shrink(fail.b).map { Tuple10(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j) } +
            AC().shrink(fail.c).map { Tuple10(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j) } +
            AD().shrink(fail.d).map { Tuple10(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j) } +
            AE().shrink(fail.e).map { Tuple10(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j) } +
            AF().shrink(fail.f).map { Tuple10(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j) } +
            AG().shrink(fail.g).map { Tuple10(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j) } +
            AH().shrink(fail.h).map { Tuple10(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j) } +
            AI().shrink(fail.i).map { Tuple10(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j) } +
            AJ().shrink(fail.j).map { Tuple10(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, F1> fromTup(
    noinline g: (F1) -> Tuple10<A, B, C, D, E, F, G, H, I, J>,
    noinline f: (Tuple10<A, B, C, D, E, F, G, H, I, J>) -> F1,
    arb: Arbitrary<Tuple10<A, B, C, D, E, F, G, H, I, J>> = Tuple10.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple11Arbitrary<A, B, C, D, E, F, G, H, I, J, K> : Arbitrary<Tuple11<A, B, C, D, E, F, G, H, I, J, K>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    override fun arbitrary(): Gen<Tuple11<A, B, C, D, E, F, G, H, I, J, K>> = Gen.monad().fx {
        Tuple11(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple11<A, B, C, D, E, F, G, H, I, J, K>): Sequence<Tuple11<A, B, C, D, E, F, G, H, I, J, K>> =
        AA().shrink(fail.a).map { Tuple11(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k) } +
            AB().shrink(fail.b).map { Tuple11(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k) } +
            AC().shrink(fail.c).map { Tuple11(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k) } +
            AD().shrink(fail.d).map { Tuple11(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k) } +
            AE().shrink(fail.e).map { Tuple11(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k) } +
            AF().shrink(fail.f).map { Tuple11(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k) } +
            AG().shrink(fail.g).map { Tuple11(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k) } +
            AH().shrink(fail.h).map { Tuple11(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k) } +
            AI().shrink(fail.i).map { Tuple11(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k) } +
            AJ().shrink(fail.j).map { Tuple11(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k) } +
            AK().shrink(fail.k).map { Tuple11(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, F1> fromTup(
    noinline g: (F1) -> Tuple11<A, B, C, D, E, F, G, H, I, J, K>,
    noinline f: (Tuple11<A, B, C, D, E, F, G, H, I, J, K>) -> F1,
    arb: Arbitrary<Tuple11<A, B, C, D, E, F, G, H, I, J, K>> = Tuple11.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple12Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L> : Arbitrary<Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    override fun arbitrary(): Gen<Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>> = Gen.monad().fx {
        Tuple12(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>): Sequence<Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>> =
        AA().shrink(fail.a).map { Tuple12(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AB().shrink(fail.b).map { Tuple12(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AC().shrink(fail.c).map { Tuple12(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AD().shrink(fail.d).map { Tuple12(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AE().shrink(fail.e).map { Tuple12(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AF().shrink(fail.f).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AG().shrink(fail.g).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l) } +
            AH().shrink(fail.h).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l) } +
            AI().shrink(fail.i).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l) } +
            AJ().shrink(fail.j).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l) } +
            AK().shrink(fail.k).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l) } +
            AL().shrink(fail.l).map { Tuple12(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, F1> fromTup(
    noinline g: (F1) -> Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>,
    noinline f: (Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>) -> F1,
    arb: Arbitrary<Tuple12<A, B, C, D, E, F, G, H, I, J, K, L>> = Tuple12.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple13Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M> : Arbitrary<Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    override fun arbitrary(): Gen<Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>> = Gen.monad().fx {
        Tuple13(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>): Sequence<Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>> =
        AA().shrink(fail.a).map { Tuple13(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AB().shrink(fail.b).map { Tuple13(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AC().shrink(fail.c).map { Tuple13(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AD().shrink(fail.d).map { Tuple13(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AE().shrink(fail.e).map { Tuple13(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AF().shrink(fail.f).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AG().shrink(fail.g).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AH().shrink(fail.h).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m) } +
            AI().shrink(fail.i).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m) } +
            AJ().shrink(fail.j).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m) } +
            AK().shrink(fail.k).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m) } +
            AL().shrink(fail.l).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m) } +
            AM().shrink(fail.m).map { Tuple13(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, F1> fromTup(
    noinline g: (F1) -> Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>,
    noinline f: (Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>) -> F1,
    arb: Arbitrary<Tuple13<A, B, C, D, E, F, G, H, I, J, K, L, M>> = Tuple13.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple14Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N> : Arbitrary<Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    override fun arbitrary(): Gen<Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>> = Gen.monad().fx {
        Tuple14(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>): Sequence<Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>> =
        AA().shrink(fail.a).map { Tuple14(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AB().shrink(fail.b).map { Tuple14(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AC().shrink(fail.c).map { Tuple14(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AD().shrink(fail.d).map { Tuple14(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AE().shrink(fail.e).map { Tuple14(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AF().shrink(fail.f).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AG().shrink(fail.g).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AH().shrink(fail.h).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AI().shrink(fail.i).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n) } +
            AJ().shrink(fail.j).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n) } +
            AK().shrink(fail.k).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n) } +
            AL().shrink(fail.l).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n) } +
            AM().shrink(fail.m).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n) } +
            AN().shrink(fail.n).map { Tuple14(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, F1> fromTup(
    noinline g: (F1) -> Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>,
    noinline f: (Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>) -> F1,
    arb: Arbitrary<Tuple14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>> = Tuple14.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple15Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> : Arbitrary<Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    override fun arbitrary(): Gen<Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>> = Gen.monad().fx {
        Tuple15(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>): Sequence<Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>> =
        AA().shrink(fail.a).map { Tuple15(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AB().shrink(fail.b).map { Tuple15(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AC().shrink(fail.c).map { Tuple15(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AD().shrink(fail.d).map { Tuple15(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AE().shrink(fail.e).map { Tuple15(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AF().shrink(fail.f).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AG().shrink(fail.g).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AH().shrink(fail.h).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AI().shrink(fail.i).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AJ().shrink(fail.j).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o) } +
            AK().shrink(fail.k).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o) } +
            AL().shrink(fail.l).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o) } +
            AM().shrink(fail.m).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o) } +
            AN().shrink(fail.n).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o) } +
            AO().shrink(fail.o).map { Tuple15(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, F1> fromTup(
    noinline g: (F1) -> Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>,
    noinline f: (Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>) -> F1,
    arb: Arbitrary<Tuple15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>> = Tuple15.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple16Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> : Arbitrary<Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    fun AP(): Arbitrary<P>
    override fun arbitrary(): Gen<Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>> = Gen.monad().fx {
        Tuple16(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind(), AP().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>): Sequence<Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>> =
        AA().shrink(fail.a).map { Tuple16(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AB().shrink(fail.b).map { Tuple16(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AC().shrink(fail.c).map { Tuple16(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AD().shrink(fail.d).map { Tuple16(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AE().shrink(fail.e).map { Tuple16(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AF().shrink(fail.f).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AG().shrink(fail.g).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AH().shrink(fail.h).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AI().shrink(fail.i).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AJ().shrink(fail.j).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AK().shrink(fail.k).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o, fail.p) } +
            AL().shrink(fail.l).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o, fail.p) } +
            AM().shrink(fail.m).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o, fail.p) } +
            AN().shrink(fail.n).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o, fail.p) } +
            AO().shrink(fail.o).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it, fail.p) } +
            AP().shrink(fail.p).map { Tuple16(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, reified P, F1> fromTup(
    noinline g: (F1) -> Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>,
    noinline f: (Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>) -> F1,
    arb: Arbitrary<Tuple16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>> = Tuple16.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit,
    dummy16: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple17Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> : Arbitrary<Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    fun AP(): Arbitrary<P>
    fun AQ(): Arbitrary<Q>
    override fun arbitrary(): Gen<Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>> = Gen.monad().fx {
        Tuple17(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind(), AP().arbitrary().bind(), AQ().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>): Sequence<Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>> =
        AA().shrink(fail.a).map { Tuple17(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AB().shrink(fail.b).map { Tuple17(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AC().shrink(fail.c).map { Tuple17(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AD().shrink(fail.d).map { Tuple17(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AE().shrink(fail.e).map { Tuple17(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AF().shrink(fail.f).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AG().shrink(fail.g).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AH().shrink(fail.h).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AI().shrink(fail.i).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AJ().shrink(fail.j).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AK().shrink(fail.k).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AL().shrink(fail.l).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o, fail.p, fail.q) } +
            AM().shrink(fail.m).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o, fail.p, fail.q) } +
            AN().shrink(fail.n).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o, fail.p, fail.q) } +
            AO().shrink(fail.o).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it, fail.p, fail.q) } +
            AP().shrink(fail.p).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, it, fail.q) } +
            AQ().shrink(fail.q).map { Tuple17(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, reified P, reified Q, F1> fromTup(
    noinline g: (F1) -> Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>,
    noinline f: (Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>) -> F1,
    arb: Arbitrary<Tuple17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>> = Tuple17.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit,
    dummy16: Unit = Unit,
    dummy17: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple18Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> : Arbitrary<Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    fun AP(): Arbitrary<P>
    fun AQ(): Arbitrary<Q>
    fun AR(): Arbitrary<R>
    override fun arbitrary(): Gen<Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>> = Gen.monad().fx {
        Tuple18(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind(), AP().arbitrary().bind(), AQ().arbitrary().bind(), AR().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>): Sequence<Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>> =
        AA().shrink(fail.a).map { Tuple18(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AB().shrink(fail.b).map { Tuple18(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AC().shrink(fail.c).map { Tuple18(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AD().shrink(fail.d).map { Tuple18(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AE().shrink(fail.e).map { Tuple18(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AF().shrink(fail.f).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AG().shrink(fail.g).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AH().shrink(fail.h).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AI().shrink(fail.i).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AJ().shrink(fail.j).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AK().shrink(fail.k).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AL().shrink(fail.l).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AM().shrink(fail.m).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o, fail.p, fail.q, fail.r) } +
            AN().shrink(fail.n).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o, fail.p, fail.q, fail.r) } +
            AO().shrink(fail.o).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it, fail.p, fail.q, fail.r) } +
            AP().shrink(fail.p).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, it, fail.q, fail.r) } +
            AQ().shrink(fail.q).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, it, fail.r) } +
            AR().shrink(fail.r).map { Tuple18(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, reified P, reified Q, reified R, F1> fromTup(
    noinline g: (F1) -> Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>,
    noinline f: (Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>) -> F1,
    arb: Arbitrary<Tuple18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>> = Tuple18.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit,
    dummy16: Unit = Unit,
    dummy17: Unit = Unit,
    dummy18: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple19Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> : Arbitrary<Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    fun AP(): Arbitrary<P>
    fun AQ(): Arbitrary<Q>
    fun AR(): Arbitrary<R>
    fun AS(): Arbitrary<S>
    override fun arbitrary(): Gen<Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>> = Gen.monad().fx {
        Tuple19(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind(), AP().arbitrary().bind(), AQ().arbitrary().bind(), AR().arbitrary().bind(), AS().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>): Sequence<Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>> =
        AA().shrink(fail.a).map { Tuple19(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AB().shrink(fail.b).map { Tuple19(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AC().shrink(fail.c).map { Tuple19(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AD().shrink(fail.d).map { Tuple19(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AE().shrink(fail.e).map { Tuple19(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AF().shrink(fail.f).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AG().shrink(fail.g).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AH().shrink(fail.h).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AI().shrink(fail.i).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AJ().shrink(fail.j).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AK().shrink(fail.k).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AL().shrink(fail.l).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AM().shrink(fail.m).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AN().shrink(fail.n).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o, fail.p, fail.q, fail.r, fail.s) } +
            AO().shrink(fail.o).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it, fail.p, fail.q, fail.r, fail.s) } +
            AP().shrink(fail.p).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, it, fail.q, fail.r, fail.s) } +
            AQ().shrink(fail.q).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, it, fail.r, fail.s) } +
            AR().shrink(fail.r).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, it, fail.s) } +
            AS().shrink(fail.s).map { Tuple19(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, reified P, reified Q, reified R, reified S, F1> fromTup(
    noinline g: (F1) -> Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>,
    noinline f: (Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>) -> F1,
    arb: Arbitrary<Tuple19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>> = Tuple19.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit,
    dummy16: Unit = Unit,
    dummy17: Unit = Unit,
    dummy18: Unit = Unit,
    dummy19: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple20Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> : Arbitrary<Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    fun AP(): Arbitrary<P>
    fun AQ(): Arbitrary<Q>
    fun AR(): Arbitrary<R>
    fun AS(): Arbitrary<S>
    fun AT(): Arbitrary<T>
    override fun arbitrary(): Gen<Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>> = Gen.monad().fx {
        Tuple20(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind(), AP().arbitrary().bind(), AQ().arbitrary().bind(), AR().arbitrary().bind(), AS().arbitrary().bind(), AT().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>): Sequence<Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>> =
        AA().shrink(fail.a).map { Tuple20(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AB().shrink(fail.b).map { Tuple20(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AC().shrink(fail.c).map { Tuple20(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AD().shrink(fail.d).map { Tuple20(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AE().shrink(fail.e).map { Tuple20(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AF().shrink(fail.f).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AG().shrink(fail.g).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AH().shrink(fail.h).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AI().shrink(fail.i).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AJ().shrink(fail.j).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AK().shrink(fail.k).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AL().shrink(fail.l).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AM().shrink(fail.m).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AN().shrink(fail.n).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AO().shrink(fail.o).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it, fail.p, fail.q, fail.r, fail.s, fail.t) } +
            AP().shrink(fail.p).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, it, fail.q, fail.r, fail.s, fail.t) } +
            AQ().shrink(fail.q).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, it, fail.r, fail.s, fail.t) } +
            AR().shrink(fail.r).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, it, fail.s, fail.t) } +
            AS().shrink(fail.s).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, it, fail.t) } +
            AT().shrink(fail.t).map { Tuple20(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, reified P, reified Q, reified R, reified S, reified T, F1> fromTup(
    noinline g: (F1) -> Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>,
    noinline f: (Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>) -> F1,
    arb: Arbitrary<Tuple20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>> = Tuple20.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit,
    dummy16: Unit = Unit,
    dummy17: Unit = Unit,
    dummy18: Unit = Unit,
    dummy19: Unit = Unit,
    dummy20: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

@extension
interface Tuple21Arbitrary<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> : Arbitrary<Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>> {
    fun AA(): Arbitrary<A>
    fun AB(): Arbitrary<B>
    fun AC(): Arbitrary<C>
    fun AD(): Arbitrary<D>
    fun AE(): Arbitrary<E>
    fun AF(): Arbitrary<F>
    fun AG(): Arbitrary<G>
    fun AH(): Arbitrary<H>
    fun AI(): Arbitrary<I>
    fun AJ(): Arbitrary<J>
    fun AK(): Arbitrary<K>
    fun AL(): Arbitrary<L>
    fun AM(): Arbitrary<M>
    fun AN(): Arbitrary<N>
    fun AO(): Arbitrary<O>
    fun AP(): Arbitrary<P>
    fun AQ(): Arbitrary<Q>
    fun AR(): Arbitrary<R>
    fun AS(): Arbitrary<S>
    fun AT(): Arbitrary<T>
    fun AU(): Arbitrary<U>
    override fun arbitrary(): Gen<Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>> = Gen.monad().fx {
        Tuple21(AA().arbitrary().bind(), AB().arbitrary().bind(), AC().arbitrary().bind(), AD().arbitrary().bind(), AE().arbitrary().bind(), AF().arbitrary().bind(), AG().arbitrary().bind(), AH().arbitrary().bind(), AI().arbitrary().bind(), AJ().arbitrary().bind(), AK().arbitrary().bind(), AL().arbitrary().bind(), AM().arbitrary().bind(), AN().arbitrary().bind(), AO().arbitrary().bind(), AP().arbitrary().bind(), AQ().arbitrary().bind(), AR().arbitrary().bind(), AS().arbitrary().bind(), AT().arbitrary().bind(), AU().arbitrary().bind())
    }.fix()
    override fun shrink(fail: Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>): Sequence<Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>> =
        AA().shrink(fail.a).map { Tuple21(it, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AB().shrink(fail.b).map { Tuple21(fail.a, it, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AC().shrink(fail.c).map { Tuple21(fail.a, fail.b, it, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AD().shrink(fail.d).map { Tuple21(fail.a, fail.b, fail.c, it, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AE().shrink(fail.e).map { Tuple21(fail.a, fail.b, fail.c, fail.d, it, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AF().shrink(fail.f).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, it, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AG().shrink(fail.g).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, it, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AH().shrink(fail.h).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, it, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AI().shrink(fail.i).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, it, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AJ().shrink(fail.j).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, it, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AK().shrink(fail.k).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, it, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AL().shrink(fail.l).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, it, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AM().shrink(fail.m).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, it, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AN().shrink(fail.n).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, it, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AO().shrink(fail.o).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, it, fail.p, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AP().shrink(fail.p).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, it, fail.q, fail.r, fail.s, fail.t, fail.u) } +
            AQ().shrink(fail.q).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, it, fail.r, fail.s, fail.t, fail.u) } +
            AR().shrink(fail.r).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, it, fail.s, fail.t, fail.u) } +
            AS().shrink(fail.s).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, it, fail.t, fail.u) } +
            AT().shrink(fail.t).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, it, fail.u) } +
            AU().shrink(fail.u).map { Tuple21(fail.a, fail.b, fail.c, fail.d, fail.e, fail.f, fail.g, fail.h, fail.i, fail.j, fail.k, fail.l, fail.m, fail.n, fail.o, fail.p, fail.q, fail.r, fail.s, fail.t, it) }
}

inline fun <reified A, reified B, reified C, reified D, reified E, reified F, reified G, reified H, reified I, reified J, reified K, reified L, reified M, reified N, reified O, reified P, reified Q, reified R, reified S, reified T, reified U, F1> fromTup(
    noinline g: (F1) -> Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>,
    noinline f: (Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>) -> F1,
    arb: Arbitrary<Tuple21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>> = Tuple21.arbitrary(defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary(), defArbitrary()),
    dummy3: Unit = Unit,
    dummy4: Unit = Unit,
    dummy5: Unit = Unit,
    dummy6: Unit = Unit,
    dummy7: Unit = Unit,
    dummy8: Unit = Unit,
    dummy9: Unit = Unit,
    dummy10: Unit = Unit,
    dummy11: Unit = Unit,
    dummy12: Unit = Unit,
    dummy13: Unit = Unit,
    dummy14: Unit = Unit,
    dummy15: Unit = Unit,
    dummy16: Unit = Unit,
    dummy17: Unit = Unit,
    dummy18: Unit = Unit,
    dummy19: Unit = Unit,
    dummy20: Unit = Unit,
    dummy21: Unit = Unit): Arbitrary<F1> = object : Arbitrary<F1> {
    override fun arbitrary(): Gen<F1> = arb.arbitrary().map(f)
    override fun shrink(fail: F1): Sequence<F1> = shrinkMap(g, f, arb).invoke(fail)
}

